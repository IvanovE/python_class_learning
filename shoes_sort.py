from sneakers_task.sneakers import Sneakersfrom sneakers_task.weddingheels import Weddingheelsfrom sneakers_task import test_generatedata = []def shoes_sort(data, season=None, wedding=None, color=None, max_price=0, min_price=0, size=None):    """    Подборка обуви по заданным пользователем параметрам    :param season: требуемые сезоны    :param wedding: признак свадебности    :param color: требуемые цвета    :param max_price: максимальная требуемая цена    :param min_price: минимальная требуемая цена    :param size: требуемые размеры    :return: подборка обуви по требованиям клиента    """    return_data = set()    data_price_increase = set()    data_price_decrease = set()    if season and wedding:        return 'Error'    if season:        return_data = {i for i in data if isinstance(i, Sneakers) and preprocessing(season).intersection(i.season)}    if wedding:        return_data = {i for i in data if isinstance(i, Weddingheels)}    if return_data == set():        return_data = data    if color:        return_data = {i for i in return_data if i.color.intersection(preprocessing(color))}    if size:        return_data = {i for i in return_data if i.check_on_stock().intersection(preprocessing(size))}    if max_price:        data_price_increase = {i for i in return_data if max_price < i.price <= max_price + 3000}        data_price_decrease = {i for i in return_data if min_price - 3000 <= i.price < min_price}        return_data = {i for i in return_data if min_price <= i.price <= max_price}    elif min_price:        data_price_decrease = {i for i in return_data if min_price - 3000 <= i.price < min_price}        return_data = {i for i in return_data if min_price <= i.price}    return return_data, data_price_decrease, data_price_increasedef preprocessing_str(x):    """    Приведение данных к нижнему регистру в зависимости от типа данных    :param x: тип данных    :return: тип данных с нижним регистром    """    new_x = set()    if type(x) is set or type(x) is tuple:        new_x = {i.lower() for i in x if type(i) is str}    elif type(x) is str:        new_x = x.lower()    if new_x:        return new_x    else:        return xdef preprocessing(x):    """    Приведение к типу set в зависимости от типа входимых данных    :param x: тип данных    :return: set, который нужно передать в функцию preprocessing_str    """    if type(x) is list:        return preprocessing_str(set(x))    if type(x) is int:        empty_set = set()        empty_set.add(x)        return empty_set    if type(x) is str:        empty_set = set()        empty_set.add(x)        return preprocessing_str(empty_set)    if type(x) is set:        return preprocessing_str(x)    if type(x) is tuple:        return preprocessing_str(set(x))    return preprocessing_str(x)if __name__ == '__main__':    data = test_generate.generate_sneakers(10) + test_generate.generate_weddingheels(5) + test_generate.generate_heels(4)    print(data)    print('\n\n\n')    print(shoes_sort(data, size=40, min_price=10000, max_price=15000))